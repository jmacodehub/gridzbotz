// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ PROJECT FLASH V5+ - PRODUCTION + R&D HYBRID ENTRY POINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Purpose:
//   Unified orchestrator with modular analytics, redundant feeds,
//   and integrated PaperTradingEngine for dry-run R&D with real market data.
//
// October 2025 - Project Flash V5+ Unified Trading Foundation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use anyhow::{Context, Result};
use clap::Parser;
use log::{error, info, warn};
use solana_grid_bot::{
    bots::GridBot,
    config::Config,
    init,
    strategies::shared::AnalyticsContext,
    trading::{feed_ids, paper_trader::PaperTradingEngine, RedundantPriceFeed},
};
use std::{
    error::Error,
    path::PathBuf,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::Instant,
};
use tokio::time::{sleep, Duration};
use chrono;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARGUMENTS & LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#[derive(Parser, Debug)]
#[clap(name = "Project Flash V5+ Modular", version = "5.0.0")]
struct Args {
  #[clap(short = 'c', long = "config")] config: Option<PathBuf>,
  #[clap(short = 'p', long = "profile")] profile: Option<String>,
  #[clap(long = "dry-run")] dry_run: bool,
  #[clap(long = "validate-only")] validate_only: bool,
  #[clap(long = "duration-minutes")] duration_minutes: Option<u64>,
  #[clap(long = "duration-hours")] duration_hours: Option<f64>,
  #[clap(long = "debug")] debug: bool,
  #[clap(long = "trace")] trace: bool,
  #[clap(short = 'q', long = "quiet")] quiet: bool,
}

fn setup_logging(args: &Args) {
  let level = if args.quiet { log::LevelFilter::Error }
   else if args.trace { log::LevelFilter::Trace }
   else if args.debug { log::LevelFilter::Debug }
   else { log::LevelFilter::Info };
  env_logger::Builder::from_default_env()
   .filter_level(level)
   .format_timestamp_secs()
   .init();
  info!("ğŸ”Š Logging initialized at {:?}", level);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION METRICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
struct SessionMetrics {
  start: Instant,
  cycles: u32,
  errors: u32,
  repositions: u32,
}
impl SessionMetrics {
  fn new() -> Self { Self { start: Instant::now(), cycles: 0, errors: 0, repositions: 0 } }
  fn record(&mut self) { self.cycles += 1; }
  fn summary(&self) {
   let elapsed = self.start.elapsed().as_secs_f64();
   println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   println!("ğŸ“Š Summary - {} cycles | Runtime {:.2}s", self.cycles, elapsed);
   println!("  Avg cycle time â‰ˆ {:.2}ms", elapsed * 1000.0 / self.cycles as f64);
   println!("  Grid repositions: {}  Errors: {}", self.repositions, self.errors);
   println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION - BOT + FEED + OPTIONAL PAPER ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async fn initialize_components(
  config: &Config,
  dry: bool,
) -> Result<(GridBot, RedundantPriceFeed, Option<PaperTradingEngine>)> {
  info!("ğŸ§  Initializing bot and redundant feedâ€¦");

  let ctx = AnalyticsContext::default();
  let bot = GridBot::new(config.clone(), ctx)?;
  let feed = RedundantPriceFeed::new(config.trading.volatility_window, feed_ids::SOL_USD.to_string());
  feed.start().await?;
  sleep(Duration::from_millis(config.performance.startup_delay_ms.max(2000))).await;
  info!("âœ… Price feeds warmed and active");

  let paper = if dry {
   info!("ğŸ® Activating PaperTradingEngine for dry-run R&D");
   Some(
     PaperTradingEngine::new(config.wallet.initial_usdc, config.wallet.initial_sol)
      .with_slippage(0.0005)
      .with_fees(0.0002, 0.0004),
   )
  } else { None };

  Ok((bot, feed, paper))
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP - REAL PRICES FOR LIVE OR SIMULATED EXECUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async fn run_trading_loop(
  config: &Config,
  bot: &mut GridBot,
  feed: &RedundantPriceFeed,
  paper: Option<PaperTradingEngine>,
  signal: Arc<AtomicBool>,
  dry: bool,
) -> Result<SessionMetrics> {
  let mut m = SessionMetrics::new();
  let total = config.paper_trading.calculate_cycles(config.performance.cycle_interval_ms as f64);
  let interval = config.performance.cycle_interval_ms;
  let mut last = feed.latest_price().await;

  for i in 1..=total {
   if signal.load(Ordering::Relaxed) { break; }
   let price = feed.latest_price().await;
   if price <= 0.0 { continue; }
   bot.process_price_update(price, chrono::Utc::now().timestamp()).await.ok();
   if dry {
     if let Some(ref engine) = paper {
      let fills = engine.process_price_update(price).await?.len();
      if fills > 0 {
        let w = engine.get_wallet().await;
        info!("ğŸ’š Fills :{} P&L :${:.2} ROI {:.2}%", fills, w.pnl_usdc(price), w.roi(price));
      }
     }
   }
   let pc = if last > 0.0 { (price - last) / last * 100.0 } else { 0.0 };
   println!("{} Cycle {:>4}/{:<4} SOL ${:>8.4} ({:+5.2}%)", if dry { "ğŸ§ª" } else { "ğŸ’°" }, i, total, price, pc);
   last = price;
   m.record();
   sleep(Duration::from_millis(interval)).await;
  }
  Ok(m)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLEANUP PHASE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async fn shutdown_components(
  bot: &mut GridBot,
  feed: &RedundantPriceFeed,
  paper: Option<PaperTradingEngine>,
  dry: bool,
) -> Result<()> {
  let p = feed.latest_price().await;
  if dry {
   if let Some(e) = paper { e.display_status(p).await; }
  } else {
   let b = bot.engine.get_balances().await;
   info!("ğŸ’° USDC {:.2} | SOL {:.4}", b["USDC"], b["SOL"]);
  }
  info!("âœ… Components shutdown @ ${:.4}", p);
  Ok(())
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN ENTRY POINT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
  let args = Args::parse();
  setup_logging(&args);
  init()?;
  let cfg = Config::load(&args.config).context("Failed config load")?;

  if args.validate_only {
   info!("âœ… Configuration OK");
   return Ok(());
  }

  let (mut bot, feed, paper) = initialize_components(&cfg, args.dry_run).await?;
  let shutdown = Arc::new(AtomicBool::new(false));
  let sig = shutdown.clone();
  tokio::spawn(async move {
   if tokio::signal::ctrl_c().await.is_ok() {
     sig.store(true, Ordering::Relaxed);
     warn!("ğŸ›‘ CTRL-C â†’ Shutdown");
   }
  });
  let metrics = run_trading_loop(&cfg, &mut bot, &feed, paper.clone(), shutdown, args.dry_run).await?;
  shutdown_components(&mut bot, &feed, paper, args.dry_run).await?;
  metrics.summary();
  if args.dry_run {
   println!("ğŸ§ª DRY-RUN COMPLETED - Paper trading with real prices");
  } else {
   println!("âœ… LIVE SESSION COMPLETED SUCCESSFULLY");
  }
  Ok(())
}
