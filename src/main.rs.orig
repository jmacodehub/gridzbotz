//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//! ğŸš€ Solana Grid Trading Bot v3.0 â€“ Production Edition
//! Modular | Robust | Extensible | Lightning-Fast
//! October 17, 2025
//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use solana_grid_bot::init;
use solana_grid_bot::config::Config;
use solana_grid_bot::bots::GridBot;
use solana_grid_bot::trading::{get_live_price, live_feed_ids};
use std::{error::Error, time::Instant};
use log::{info, warn, error, debug};
use tokio::time::{sleep, Duration};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DEMO_CYCLES: u32 = 50;
const CYCLE_INTERVAL_MS: u64 = 100;
const STARTUP_DELAY_MS: u64 = 1000;
const PRICE_HISTORY_SIZE: usize = 20;
const SLOW_CYCLE_THRESHOLD_MS: u64 = 200;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION METRICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

struct SessionMetrics {
    start_time: Instant,
    cycle_times: Vec<u64>,
    repositions: u32,
    errors: u32,
    price_updates: u64,
    successful_cycles: u32,
    failed_price_fetches: u32,
}

impl SessionMetrics {
    fn new() -> Self {
        Self {
            start_time: Instant::now(),
            cycle_times: Vec::with_capacity(DEMO_CYCLES as usize),
            repositions: 0,
            errors: 0,
            price_updates: 0,
            successful_cycles: 0,
            failed_price_fetches: 0,
        }
    }
    
    fn record_cycle(&mut self, duration_ms: u64) {
        self.cycle_times.push(duration_ms);
        self.successful_cycles += 1;
    }
    
    fn avg_cycle_time(&self) -> f64 {
        if self.cycle_times.is_empty() {
            0.0
        } else {
            self.cycle_times.iter().sum::<u64>() as f64 / self.cycle_times.len() as f64
        }
    }
    
    fn min_cycle_time(&self) -> u64 {
        *self.cycle_times.iter().min().unwrap_or(&0)
    }
    
    fn max_cycle_time(&self) -> u64 {
        *self.cycle_times.iter().max().unwrap_or(&0)
    }
    
    fn elapsed_secs(&self) -> f64 {
        self.start_time.elapsed().as_secs_f64()
    }
    
    fn success_rate(&self) -> f64 {
        if self.price_updates == 0 {
            return 0.0;
        }
        ((self.price_updates - self.failed_price_fetches as u64) as f64 / self.price_updates as f64) * 100.0
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn print_banner() {
    let border = "â•".repeat(78);
    println!("\n{}", border);
    println!("     ğŸš€ SOLANA GRID TRADING BOT v3.0 - PRODUCTION EDITION");
    println!("     âš¡ Lightning-Fast Cycles â€¢ Live Feeds â€¢ Dynamic Grids");
    println!("{}", border);
}

fn progress_bar(current: u32, total: u32) -> String {
    let percentage = (current as f64 / total as f64 * 100.0) as u32;
    let filled = (percentage / 5) as usize;
    let empty = 20 - filled;
    format!("[{}{}] {}%", "â–ˆ".repeat(filled), "â–‘".repeat(empty), percentage)
}

fn calculate_volatility(prices: &[f64]) -> f64 {
    if prices.len() < 2 {
        return 0.0;
    }
    let mean = prices.iter().sum::<f64>() / prices.len() as f64;
    let variance = prices.iter()
        .map(|&p| (p - mean).powi(2))
        .sum::<f64>() / prices.len() as f64;
    (variance.sqrt() / mean) * 100.0
}

fn print_summary(metrics: &SessionMetrics, cycles_completed: u32, feed_health: bool) {
    let border = "â•".repeat(78);
    println!("\n{}", border);
    println!("     ğŸ“Š SESSION SUMMARY - PERFORMANCE REPORT");
    println!("{}", border);
    
    println!("\nâ±ï¸  TIMING METRICS:");
    println!("   Total Runtime:       {:.2}s", metrics.elapsed_secs());
    println!("   Cycles Completed:    {}/{}", cycles_completed, DEMO_CYCLES);
    println!("   Avg Cycle Time:      {:.2}ms ğŸ¯", metrics.avg_cycle_time());
    println!("   Min Cycle Time:      {}ms âš¡", metrics.min_cycle_time());
    println!("   Max Cycle Time:      {}ms", metrics.max_cycle_time());
    
    println!("\nğŸ“ˆ TRADING METRICS:");
    println!("   Grid Repositions:    {} times", metrics.repositions);
    println!("   Price Updates:       {} total", metrics.price_updates);
    println!("   Successful Cycles:   {}", metrics.successful_cycles);
    println!("   Errors Encountered:  {}", metrics.errors);
    
    println!("\nğŸŒ NETWORK HEALTH:");
    println!("   Price Feed:          {}", if feed_health { "âœ… Healthy" } else { "ğŸ”´ Degraded" });
    println!("   RPC Success Rate:    {:.1}%", metrics.success_rate());
    println!("   Failed Fetches:      {}", metrics.failed_price_fetches);
    
    let avg = metrics.avg_cycle_time();
    println!("\nğŸ† PERFORMANCE VERDICT:");
    if avg < 150.0 {
        println!("   Status:              âš¡ EXCELLENT - Lightning Fast!");
    } else if avg < 300.0 {
        println!("   Status:              âœ… GOOD - Under 300ms");
    } else if avg < 600.0 {
        println!("   Status:              ğŸ‘ ACCEPTABLE - Under 600ms");
    } else {
        println!("   Status:              âš ï¸  NEEDS OPTIMIZATION");
    }
    
    println!("\n{}\n", border);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize logger
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .format_timestamp_millis()
        .init();

    print_banner();
    let mut metrics = SessionMetrics::new();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INITIALIZATION
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    info!("ğŸ”§ Initializing core systems...");
    init().map_err(|e| format!("âŒ Core init failed: {}", e))?;
    
    let config = Config::load()
        .map_err(|e| format!("âŒ Config load failed: {}", e))?;
    info!("âœ… Core initialized & config loaded");
    config.display_summary();

    info!("ğŸ¤– Setting up GridBot...");
    let mut bot = GridBot::new(config.clone())
        .map_err(|e| format!("âŒ GridBot creation failed: {}", e))?;
    bot.initialize().await
        .map_err(|e| format!("âŒ GridBot initialization failed: {}", e))?;
    info!("âœ… GridBot ready for trading");

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WARM UP PRICE FEED
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    println!("\nâ³ Warming up price feed ({} ms)...", STARTUP_DELAY_MS);
    sleep(Duration::from_millis(STARTUP_DELAY_MS)).await;
    
    let initial_price = get_live_price(live_feed_ids::SOL_USD).await
        .ok_or("âŒ Failed to fetch initial price")?;
    println!("ğŸ’° Initial SOL/USD: ${:.4}\n", initial_price);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // GRACEFUL SHUTDOWN SETUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    let shutdown = Arc::new(AtomicBool::new(false));
    let shutdown_clone = Arc::clone(&shutdown);
    
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.expect("Failed to listen for Ctrl+C");
        warn!("ğŸ›‘ Shutdown signal received");
        shutdown_clone.store(true, Ordering::Relaxed);
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // MAIN TRADING LOOP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    println!("ğŸ”¥ STARTING OPTIMIZED DEMO ({} cycles @ {}ms intervals)\n", DEMO_CYCLES, CYCLE_INTERVAL_MS);
    println!("{}", "â”€".repeat(78));

    let mut last_price = initial_price;
    let mut price_history: Vec<f64> = Vec::with_capacity(PRICE_HISTORY_SIZE);
    price_history.push(initial_price);

    for cycle in 1..=DEMO_CYCLES {
        // Check for shutdown signal
        if shutdown.load(Ordering::Relaxed) {
            warn!("ğŸ›‘ Graceful shutdown initiated at cycle {}", cycle);
            break;
        }
        
        let cycle_start = Instant::now();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // FETCH PRICE
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        let price = match get_live_price(live_feed_ids::SOL_USD).await {
            Some(p) => {
                metrics.price_updates += 1;
                p
            }
            None => {
                metrics.errors += 1;
                metrics.failed_price_fetches += 1;
                error!("âŒ Price feed error at cycle {}", cycle);
                sleep(Duration::from_millis(CYCLE_INTERVAL_MS)).await;
                continue;
            }
        };

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // UPDATE PRICE HISTORY & CALCULATE METRICS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        price_history.push(price);
        if price_history.len() > PRICE_HISTORY_SIZE {
            price_history.remove(0);
        }
        
        let price_change = ((price - last_price) / last_price) * 100.0;
        let volatility = calculate_volatility(&price_history);

        let trend_emoji = match price_change {
            pc if pc.abs() < 0.005 => "â¡ï¸",
            pc if pc > 0.05 => "ğŸš€",
            pc if pc > 0.0 => "ğŸ“ˆ",
            pc if pc < -0.05 => "ğŸ’¥",
            _ => "ğŸ“‰",
        };

        print!("Cycle {:>3}/{:<3} {} | SOL ${:>9.4} ({:>+6.3}%) | Vol: {:>5.2}% | ",
               cycle, DEMO_CYCLES, trend_emoji, price, price_change, volatility);

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // GRID REPOSITIONING
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        if bot.should_reposition(price, last_price).await {
            match bot.reposition_grid(price, last_price).await {
                Ok(_) => {
                    metrics.repositions += 1;
                    println!("ğŸ¯ REPOSITIONED");
                }
                Err(e) => {
                    metrics.errors += 1;
                    println!("âš ï¸  REPOSITION FAILED");
                    error!("Reposition error: {}", e);
                }
            }
        } else {
            println!("âœ“ Grid stable");
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PROCESS PRICE UPDATE IN BOT
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        if let Err(e) = bot.process_price_update(price, chrono::Utc::now().timestamp()).await {
            error!("Failed to process price update: {}", e);
            metrics.errors += 1;
        }

        last_price = price;

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PROGRESS REPORTING
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        if cycle % (DEMO_CYCLES / 10).max(1) == 0 {
            println!("   {}", progress_bar(cycle, DEMO_CYCLES));
        }

        let cycle_duration_ms = cycle_start.elapsed().as_millis() as u64;
        metrics.record_cycle(cycle_duration_ms);
        
        if cycle_duration_ms > SLOW_CYCLE_THRESHOLD_MS {
            warn!("â±ï¸  Slow cycle #{}: {}ms (target: <{}ms)", 
                  cycle, cycle_duration_ms, SLOW_CYCLE_THRESHOLD_MS);
        }
        
        debug!("Cycle {} completed in {}ms", cycle, cycle_duration_ms);

        // Periodic status update
        if cycle % (DEMO_CYCLES / 4) == 0 && cycle > 0 {
            info!("ğŸ“Š Progress: {}/{} | Avg: {:.1}ms | Repositions: {} | Vol: {:.2}%",
                  cycle, DEMO_CYCLES, metrics.avg_cycle_time(), metrics.repositions, volatility);
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // SLEEP TO MAINTAIN CYCLE INTERVAL
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        let elapsed_ms = cycle_start.elapsed().as_millis() as u64;
        if elapsed_ms < CYCLE_INTERVAL_MS {
            sleep(Duration::from_millis(CYCLE_INTERVAL_MS - elapsed_ms)).await;
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // FINAL SUMMARY
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    let feed_health = metrics.failed_price_fetches < 5; // Less than 5 failures = healthy
    let cycles_completed = metrics.successful_cycles;
    
    print_summary(&metrics, cycles_completed, feed_health);

    // Display bot stats
    bot.display_status(last_price).await;

    info!("ğŸŒ™ GridBot session completed successfully");
    info!("ğŸ’¾ Total runtime: {:.2}s | Avg cycle: {:.2}ms", 
          metrics.elapsed_secs(), metrics.avg_cycle_time());

    Ok(())
}
